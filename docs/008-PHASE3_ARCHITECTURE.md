# Phase 3 Architecture: Advanced Features

## Overview

Phase 3 adds four advanced features to the TDS implementation:

1. **Transaction Management** — Explicit BEGIN/COMMIT/ROLLBACK
2. **Prepared Statements** — sp_prepare/sp_execute/sp_unprepare
3. **NBCRow Support** — Null Bitmap Compressed rows
4. **Cursor Support** — Server-side cursors

This document defines the clean architecture, interfaces, and integration points.

---

## Design Principles

1. **Decoupled from aul internals** — All TDS protocol code lives in `tds/` package
2. **Interface-driven** — Define interfaces that aul implements, not concrete dependencies
3. **Stateless protocol layer** — State management delegated to handlers via interfaces
4. **Testable** — Each component testable in isolation

---

## 1. Transaction Management

### 1.1 Protocol Flow

```
Client                          Server
  |                               |
  |-- BEGIN TRAN (SQL_BATCH) ---->|
  |                               |--- Create transaction
  |<-- ENVCHANGE(BeginTran) ------|    (8-byte descriptor)
  |<-- DONE --------------------- |
  |                               |
  |-- INSERT ... (SQL_BATCH) ---->|
  |<-- DONE(DoneInxact) ---------|    (flag indicates txn active)
  |                               |
  |-- COMMIT (SQL_BATCH) -------->|
  |                               |--- Commit transaction
  |<-- ENVCHANGE(CommitTran) -----|
  |<-- DONE ---------------------|
```

### 1.2 Components

```
tds/
├── transaction.go          # Transaction descriptor, ENVCHANGE helpers
└── token.go                # Extended with transaction ENVCHANGE writers

protocol/tds/
├── connection.go           # Transaction state per connection
└── txn_handler.go          # Transaction lifecycle hooks
```

### 1.3 Interfaces

```go
// TransactionManager is implemented by the application (aul) to handle
// transaction lifecycle. The TDS layer calls these hooks.
type TransactionManager interface {
    // BeginTransaction starts a new transaction and returns a descriptor.
    // The descriptor is an opaque 8-byte value sent to the client.
    BeginTransaction(ctx context.Context, name string, isolation IsolationLevel) ([]byte, error)
    
    // CommitTransaction commits the transaction identified by descriptor.
    CommitTransaction(ctx context.Context, descriptor []byte) error
    
    // RollbackTransaction rolls back the transaction.
    RollbackTransaction(ctx context.Context, descriptor []byte, savepointName string) error
    
    // CreateSavepoint creates a savepoint within the current transaction.
    CreateSavepoint(ctx context.Context, descriptor []byte, name string) error
}

// IsolationLevel represents SQL Server transaction isolation levels.
type IsolationLevel uint8

const (
    IsolationReadUncommitted IsolationLevel = 1
    IsolationReadCommitted   IsolationLevel = 2
    IsolationRepeatableRead  IsolationLevel = 3
    IsolationSerializable    IsolationLevel = 4
    IsolationSnapshot        IsolationLevel = 5
)
```

### 1.4 Transaction Descriptor

SQL Server uses an 8-byte transaction descriptor that appears in:
- ENVCHANGE tokens (BeginTran, CommitTran, RollbackTran)
- ALL_HEADERS in subsequent requests (when transaction is active)

```go
// TransactionDescriptor is an 8-byte opaque identifier for a transaction.
// It's generated by the server and included in ALL_HEADERS by the client.
type TransactionDescriptor [8]byte

// NewTransactionDescriptor creates a new descriptor.
// The format is: 4 bytes sequence + 4 bytes random/timestamp.
func NewTransactionDescriptor(seq uint32) TransactionDescriptor
```

---

## 2. Prepared Statements

### 2.1 Protocol Flow

```
Client                              Server
  |                                   |
  |-- sp_prepare(@handle OUT, ----->|
  |      @params, @stmt)             |--- Parse and store statement
  |<-- RETURNVALUE(@handle=1) ------|    Return handle (int)
  |<-- DONE -------------------------|
  |                                   |
  |-- sp_execute(@handle=1, ------->|
  |      @p1=42, @p2='foo')          |--- Execute by handle
  |<-- COLMETADATA -----------------|
  |<-- ROW(s) ----------------------|
  |<-- DONE -------------------------|
  |                                   |
  |-- sp_unprepare(@handle=1) ----->|
  |                                   |--- Release handle
  |<-- DONE -------------------------|
```

### 2.2 Components

```
tds/
├── prepared.go             # PreparedStatement struct, handle management

protocol/tds/
├── connection.go           # Prepared statement cache per connection
└── prepared_handler.go     # sp_prepare/execute/unprepare dispatch
```

### 2.3 Interfaces

```go
// PreparedStatementStore manages prepared statements for a connection.
// Implemented by the protocol layer, backed by application logic.
type PreparedStatementStore interface {
    // Prepare parses a statement and returns a handle.
    // The paramDefs string contains parameter definitions like "@p1 int, @p2 nvarchar(100)".
    Prepare(ctx context.Context, stmt string, paramDefs string) (handle int32, metadata []ColumnInfo, err error)
    
    // Execute runs a prepared statement by handle with the given parameters.
    Execute(ctx context.Context, handle int32, params []interface{}) (ResultSet, error)
    
    // Unprepare releases a prepared statement handle.
    Unprepare(ctx context.Context, handle int32) error
    
    // GetMetadata returns column metadata for a prepared statement.
    GetMetadata(handle int32) ([]ColumnInfo, bool)
}

// PreparedStatement holds a parsed statement ready for execution.
type PreparedStatement struct {
    Handle     int32
    SQL        string
    ParamDefs  string
    ParamCount int
    Columns    []ColumnInfo  // Result column metadata (if known)
    CreatedAt  time.Time
    ExecCount  int64         // Execution statistics
}
```

### 2.4 Handle Pool

```go
// HandlePool manages integer handles for prepared statements and cursors.
// Thread-safe, reuses released handles.
type HandlePool struct {
    mu       sync.Mutex
    next     int32
    released []int32
}

func (p *HandlePool) Acquire() int32
func (p *HandlePool) Release(handle int32)
```

---

## 3. NBCRow Support

### 3.1 Overview

NBCRow (Null Bitmap Compressed Row) is an optimization for result sets with many nullable columns. Instead of encoding NULL as a type-specific marker in each column, a bitmap at the start of the row indicates which columns are NULL.

### 3.2 Format

```
TokenNBCRow (0xD2)
├── NullBitmap: ceil(numColumns/8) bytes
│   └── Bit N = 1 means column N is NULL
└── ColumnData: Only non-NULL columns, in order
```

### 3.3 Components

```
tds/
├── types.go                # Extend ResultSetWriter with WriteNBCRow
└── nbcrow.go               # NBCRow encoding logic
```

### 3.4 Interface

```go
// ResultSetWriter already exists; extend with NBCRow support.
type ResultSetWriter struct {
    // ... existing fields
    useNBCRow bool  // Enable NBCRow encoding
}

// WriteNBCRow writes a row using null bitmap compression.
// More efficient when many columns are nullable.
func (w *ResultSetWriter) WriteNBCRow(values []interface{}) error

// buildNullBitmap creates the null bitmap for a row.
func buildNullBitmap(values []interface{}, numColumns int) []byte
```

### 3.5 Usage Heuristic

Use NBCRow when:
- TDS version >= 7.3 (SQL Server 2008+)
- Number of nullable columns > 4
- More than 20% of values in a typical row are NULL

---

## 4. Cursor Support

### 4.1 Protocol Flow

```
Client                              Server
  |                                   |
  |-- sp_cursoropen(@cursor OUT, -->|
  |      @stmt, @scrollopt,          |--- Open cursor
  |      @ccopt, @rowcount OUT)      |    Return cursor handle
  |<-- RETURNVALUE(@cursor=1) ------|
  |<-- RETURNVALUE(@rowcount=100) --|
  |<-- DONE -------------------------|
  |                                   |
  |-- sp_cursorfetch(@cursor=1, --->|
  |      @fetchtype=2, @rownum=1,    |--- Fetch rows
  |      @nrows=10)                  |
  |<-- COLMETADATA -----------------|
  |<-- ROW(s) ----------------------|
  |<-- DONE -------------------------|
  |                                   |
  |-- sp_cursorclose(@cursor=1) --->|
  |                                   |--- Close cursor
  |<-- DONE -------------------------|
```

### 4.2 Components

```
tds/
├── cursor.go               # Cursor types, fetch types, options

protocol/tds/
├── connection.go           # Cursor registry per connection
└── cursor_handler.go       # sp_cursor* dispatch
```

### 4.3 Interfaces

```go
// CursorManager handles server-side cursor operations.
type CursorManager interface {
    // Open creates a new cursor and returns its handle and row count.
    Open(ctx context.Context, stmt string, scrollOpt, ccOpt int32) (handle int32, rowCount int32, columns []ColumnInfo, err error)
    
    // Fetch retrieves rows from a cursor.
    // fetchType: 1=FIRST, 2=NEXT, 4=PREV, 8=LAST, 16=ABSOLUTE, 32=RELATIVE
    Fetch(ctx context.Context, handle int32, fetchType int32, rowNum int64, nRows int32) ([][]interface{}, error)
    
    // Close closes and releases a cursor.
    Close(ctx context.Context, handle int32) error
    
    // SetOption sets cursor options (e.g., scrollability).
    SetOption(ctx context.Context, handle int32, option, value int32) error
}

// CursorFetchType identifies the fetch direction.
type CursorFetchType int32

const (
    FetchFirst    CursorFetchType = 1
    FetchNext     CursorFetchType = 2
    FetchPrev     CursorFetchType = 4
    FetchLast     CursorFetchType = 8
    FetchAbsolute CursorFetchType = 16
    FetchRelative CursorFetchType = 32
)

// CursorScrollOpt defines cursor scrollability options.
type CursorScrollOpt int32

const (
    ScrollOptForwardOnly CursorScrollOpt = 1
    ScrollOptKeyset      CursorScrollOpt = 2
    ScrollOptDynamic     CursorScrollOpt = 4
    ScrollOptStatic      CursorScrollOpt = 8
    ScrollOptFastForward CursorScrollOpt = 16
)

// CursorConcurrencyOpt defines cursor concurrency options.
type CursorConcurrencyOpt int32

const (
    CCOptReadOnly     CursorConcurrencyOpt = 1
    CCOptScrollLocks  CursorConcurrencyOpt = 2
    CCOptOptimistic   CursorConcurrencyOpt = 4
    CCOptOptimisticValues CursorConcurrencyOpt = 8
)
```

### 4.4 Cursor State

```go
// Cursor represents an open server-side cursor.
type Cursor struct {
    Handle      int32
    SQL         string
    Columns     []ColumnInfo
    ScrollOpt   CursorScrollOpt
    CCOpt       CursorConcurrencyOpt
    Position    int64           // Current row position (1-based)
    RowCount    int32           // Total rows (-1 if unknown)
    CreatedAt   time.Time
    LastFetch   time.Time
}
```

---

## 5. Integration Points

### 5.1 Connection State Extension

```go
// ConnectionState holds Phase 3 state for a TDS connection.
type ConnectionState struct {
    // Transaction state
    ActiveTransaction *TransactionDescriptor
    TransactionName   string
    IsolationLevel    IsolationLevel
    
    // Prepared statement cache
    PreparedStatements map[int32]*PreparedStatement
    stmtHandlePool     *HandlePool
    
    // Cursor registry
    Cursors          map[int32]*Cursor
    cursorHandlePool *HandlePool
}
```

### 5.2 RPC Dispatcher Extension

The existing `parseRPCRequest` returns a `protocol.Request`. For Phase 3, we extend the request handling:

```go
// RequestType additions
const (
    RequestPrepare    RequestType = 10  // sp_prepare
    RequestExecuteStmt RequestType = 11  // sp_execute (prepared)
    RequestUnprepare  RequestType = 12  // sp_unprepare
    RequestCursorOpen RequestType = 20  // sp_cursoropen
    RequestCursorFetch RequestType = 21  // sp_cursorfetch
    RequestCursorClose RequestType = 22  // sp_cursorclose
)
```

### 5.3 Handler Hooks

```go
// Phase3Handlers groups the handler interfaces for Phase 3 features.
// The application (aul) provides implementations.
type Phase3Handlers struct {
    Transactions TransactionManager
    Prepared     PreparedStatementStore
    Cursors      CursorManager
}

// Connection uses these handlers for Phase 3 operations.
type Connection struct {
    // ... existing fields
    phase3 *Phase3Handlers
}
```

---

## 6. File Structure

```
tds/
├── transaction.go      # Transaction descriptor, ENVCHANGE helpers
├── prepared.go         # PreparedStatement struct, handle pool
├── cursor.go           # Cursor types, options, fetch types
├── nbcrow.go           # NBCRow encoding
└── token.go            # Extended with transaction/cursor tokens

protocol/tds/
├── connection.go       # Extended with Phase3 state
├── phase3.go           # Phase3Handlers, dispatcher extensions
├── txn_handler.go      # Transaction SQL parsing, ENVCHANGE emission
├── prepared_handler.go # sp_prepare/execute/unprepare handling
└── cursor_handler.go   # sp_cursor* handling
```

---

## 7. Stub Implementation Strategy

1. **Define all interfaces** in `tds/` package
2. **Create stub handlers** that return "not implemented" errors
3. **Wire stubs into connection** so go-mssqldb gets proper error responses
4. **Implement incrementally** — each feature can be completed independently

This allows:
- Immediate testability of the protocol layer
- Clear contracts for aul to implement
- Graceful degradation (clients see "not implemented" rather than protocol errors)
